#!/usr/bin/env python3
"""Create GitHub issues for diagnosed year lookup failures.

This script reads diagnostic results from diagnose_failures.py
and creates GitHub issues for each failed album.

Usage:
    uv run python scripts/create_issue.py \
        --input diagnostic_results.json \
        --repo barad1tos/GenreUpdater

Environment:
    GITHUB_TOKEN: GitHub personal access token or GITHUB_TOKEN from Actions
"""

from __future__ import annotations

import argparse
import json
import os
import sys
from dataclasses import dataclass
from datetime import UTC, datetime
from pathlib import Path
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from github.Issue import Issue
    from github.Repository import Repository

# Try to import github library, provide helpful error if missing
try:
    from github import Auth, Github
except ImportError:
    Auth = None  # type: ignore[misc, assignment]
    Github = None  # type: ignore[misc, assignment]
    print("ERROR: PyGithub not installed. Run: uv add PyGithub")
    sys.exit(1)


# =============================================================================
# DATA STRUCTURES
# =============================================================================


@dataclass
class ApiDiagnosis:
    """Diagnosis result from a single API."""

    status: str  # found, not_found, partial, error, rate_limited
    details: str
    artist_found: bool = False
    album_found: bool = False
    year_found: str | None = None
    close_matches: list[str] | None = None
    releases_found: int = 0
    raw_response: dict[str, Any] | None = None


@dataclass
class DiagnosisResult:
    """Complete diagnosis for an album."""

    artist: str
    album: str
    first_detected: str
    reason: str
    musicbrainz: ApiDiagnosis
    discogs: ApiDiagnosis
    lastfm: ApiDiagnosis
    possible_causes: list[str]
    suggested_actions: list[str]


# =============================================================================
# ISSUE FORMATTING
# =============================================================================


def status_emoji(diagnosis: ApiDiagnosis) -> str:
    """Get status emoji for API diagnosis."""
    status_map = {
        "found": "\u2705",  # Green checkmark
        "partial": "\u26a0\ufe0f",  # Warning
        "not_found": "\u274c",  # Red X
        "error": "\U0001f4a5",  # Explosion
        "rate_limited": "\u23f1\ufe0f",  # Timer
    }
    return status_map.get(diagnosis.status, "\u2753")  # Question mark for unknown


def format_checklist(items: list[str]) -> str:
    """Format list as markdown checklist."""
    if not items:
        return "_No causes identified_"
    return "\n".join(f"- [ ] {item}" for item in items)


def format_numbered_list(items: list[str]) -> str:
    """Format list as numbered markdown list."""
    if not items:
        return "_No actions suggested_"
    return "\n".join(f"{i}. {item}" for i, item in enumerate(items, 1))


def format_close_matches(matches: list[str] | None) -> str:
    """Format close matches as inline list."""
    if not matches:
        return ""
    if len(matches) <= 3:
        return f" Close: {', '.join(matches)}"
    return f" Close: {', '.join(matches[:3])}..."


def format_issue_body(d: DiagnosisResult) -> str:
    """Format diagnosis as markdown issue body."""
    now = datetime.now(UTC).strftime("%Y-%m-%d %H:%M UTC")

    # Build search URLs
    mb_search = f"https://musicbrainz.org/search?query={d.artist.replace(' ', '+')}+{d.album.replace(' ', '+')}&type=release"
    discogs_search = f"https://www.discogs.com/search/?q={d.artist.replace(' ', '+')}+{d.album.replace(' ', '+')}&type=all"

    return f"""## Year Lookup Failed: {d.artist} - {d.album}

**First detected:** {d.first_detected}
**Diagnosis run:** {now}
**Original reason:** `{d.reason}`

### API Diagnosis Results

| API | Status | Details |
|-----|--------|---------|
| MusicBrainz | {status_emoji(d.musicbrainz)} {d.musicbrainz.status} | {d.musicbrainz.details}{format_close_matches(d.musicbrainz.close_matches)} |
| Discogs | {status_emoji(d.discogs)} {d.discogs.status} | {d.discogs.details}{format_close_matches(d.discogs.close_matches)} |
| Last.fm | {status_emoji(d.lastfm)} {d.lastfm.status} | {d.lastfm.details} |

### Possible Causes

{format_checklist(d.possible_causes)}

### Suggested Actions

{format_numbered_list(d.suggested_actions)}

### Manual Verification Links

- [MusicBrainz Search]({mb_search})
- [Discogs Search]({discogs_search})

---
_Auto-generated by CI diagnostics workflow_
"""


def format_update_comment(d: DiagnosisResult) -> str:
    """Format diagnosis as update comment for existing issue."""
    now = datetime.now(UTC).strftime("%Y-%m-%d %H:%M UTC")

    return f"""## Re-diagnosis ({now})

| API | Status | Details |
|-----|--------|---------|
| MusicBrainz | {status_emoji(d.musicbrainz)} | {d.musicbrainz.details} |
| Discogs | {status_emoji(d.discogs)} | {d.discogs.details} |
| Last.fm | {status_emoji(d.lastfm)} | {d.lastfm.details} |

**New causes identified:** {len(d.possible_causes)}
**Status:** Re-diagnosed by CI workflow
"""


# =============================================================================
# GITHUB OPERATIONS
# =============================================================================


def find_existing_issue(repo: Repository, artist: str, album: str) -> Issue | None:
    """Find existing issue for this album."""
    search_term = f"{artist} - {album}"

    return next(
        (issue for issue in repo.get_issues(state="all") if search_term in issue.title and "Year Lookup Failed" in issue.title),
        None,
    )


def _update_existing_issue(
    result: dict[str, Any],
    existing: Issue,
    diagnosis: DiagnosisResult,
) -> None:
    """Update an existing issue with new diagnosis."""
    result["action"] = "updated"
    result["issue_number"] = existing.number
    result["url"] = existing.html_url

    # Add comment with new diagnosis
    comment = format_update_comment(diagnosis)
    existing.create_comment(comment)

    # Reopen if closed
    if existing.state == "closed":
        existing.edit(state="open")
        result["action"] = "reopened"


def _create_new_issue(
    result: dict[str, Any],
    diagnosis: DiagnosisResult,
    repo: Repository,
    labels: list[str],
) -> None:
    """Create a new issue for the diagnosis."""
    result["action"] = "created"

    # Create new issue
    title = f"Year Lookup Failed: {diagnosis.artist} - {diagnosis.album}"
    body = format_issue_body(diagnosis)

    issue = repo.create_issue(title=title, body=body, labels=labels)
    result["url"] = issue.html_url
    result["issue_number"] = issue.number


def create_or_update_issue(
    repo: Repository,
    diagnosis: DiagnosisResult,
    labels: list[str],
) -> dict[str, Any]:
    """Create new issue or update existing one.

    Returns dict with action taken and issue URL.
    """
    result: dict[str, Any] = {
        "artist": diagnosis.artist,
        "album": diagnosis.album,
        "action": None,
        "url": None,
        "issue_number": None,
    }

    # Check for existing issue
    if existing := find_existing_issue(repo, diagnosis.artist, diagnosis.album):
        _update_existing_issue(result, existing, diagnosis)
    else:
        _create_new_issue(result, diagnosis, repo, labels)
    return result


# =============================================================================
# LOADING DATA
# =============================================================================


def load_diagnoses(input_path: Path) -> list[DiagnosisResult]:
    """Load diagnosis results from JSON file."""
    with input_path.open() as f:
        data = json.load(f)

    # Support both formats: plain array or {"diagnoses": [...]}
    items = data if isinstance(data, list) else data.get("diagnoses", [])

    diagnoses = []
    for item in items:
        # Parse nested API diagnoses
        mb = ApiDiagnosis(**item.get("musicbrainz", {}))
        discogs = ApiDiagnosis(**item.get("discogs", {}))
        lastfm = ApiDiagnosis(**item.get("lastfm", {}))

        diagnosis = DiagnosisResult(
            artist=item["artist"],
            album=item["album"],
            first_detected=item.get("first_detected", "unknown"),
            reason=item.get("reason", "unknown"),
            musicbrainz=mb,
            discogs=discogs,
            lastfm=lastfm,
            possible_causes=item.get("possible_causes", []),
            suggested_actions=item.get("suggested_actions", []),
        )
        diagnoses.append(diagnosis)

    return diagnoses


# =============================================================================
# MAIN
# =============================================================================


def _parse_args() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Create GitHub issues for diagnosed year lookup failures",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "--input",
        type=Path,
        required=True,
        help="Path to diagnostic_results.json from diagnose_failures.py",
    )
    parser.add_argument(
        "--repo",
        type=str,
        required=True,
        help="GitHub repository (owner/repo format)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be created without actually creating",
    )
    parser.add_argument(
        "--labels",
        type=str,
        default="year-lookup-failed,automated,needs-investigation",
        help="Comma-separated labels to apply (default: year-lookup-failed,automated,needs-investigation)",
    )
    return parser.parse_args()


def _process_diagnosis_dry_run(
    diagnosis: DiagnosisResult,
    repo_name: str,
) -> dict[str, Any]:
    """Process a diagnosis in dry-run mode."""
    result: dict[str, Any] = {
        "artist": diagnosis.artist,
        "album": diagnosis.album,
        "action": "would_create",
        "url": f"https://github.com/{repo_name}/issues/NEW",
        "issue_number": None,
    }
    print(f"  Would create issue with {len(diagnosis.possible_causes)} causes")
    return result


def _process_diagnosis_real(
    diagnosis: DiagnosisResult,
    repo: Repository,
    labels: list[str],
) -> dict[str, Any]:
    """Process a diagnosis and create/update real issue."""
    result = create_or_update_issue(repo, diagnosis, labels)
    action_str = result["action"]
    print(f"  {action_str.upper() if action_str else 'UNKNOWN'}: {result['url']}")
    return result


def _print_summary(results: list[dict[str, Any]], output_path: Path, args: argparse.Namespace) -> None:
    """Print summary and save results."""
    print("\n" + "=" * 60)
    print("SUMMARY")
    print("=" * 60)

    actions: dict[str, int] = {}
    for r in results:
        action = r["action"]
        actions[action] = actions.get(action, 0) + 1

    for action, count in sorted(actions.items()):
        print(f"  {action}: {count}")

    print(f"\nTotal processed: {len(results)}")

    # Output results to JSON for CI
    with output_path.open("w") as f:
        json.dump(
            {
                "timestamp": datetime.now(UTC).isoformat(),
                "repository": args.repo,
                "dry_run": args.dry_run,
                "results": results,
            },
            f,
            indent=2,
        )
    print(f"\nResults saved to: {output_path}")


def main() -> int:
    """Main entry point."""
    args = _parse_args()

    # Validate input file
    if not args.input.exists():
        print(f"ERROR: Input file not found: {args.input}")
        return 1

    # Get GitHub token
    token = os.environ.get("GITHUB_TOKEN")
    if not token and not args.dry_run:
        print("ERROR: GITHUB_TOKEN environment variable not set")
        print("Set it with: export GITHUB_TOKEN=your_token")
        return 1

    # Parse labels
    labels = [label.strip() for label in args.labels.split(",") if label.strip()]

    # Load diagnoses
    print(f"Loading diagnoses from {args.input}...")
    diagnoses = load_diagnoses(args.input)
    print(f"Found {len(diagnoses)} diagnoses to process")

    if not diagnoses:
        print("No diagnoses to process. Exiting.")
        return 0

    # Connect to GitHub
    repo: Repository | None = None
    if args.dry_run:
        print("\n[DRY RUN MODE - No issues will be created]\n")
    else:
        github_client = Github(auth=Auth.Token(token))  # type: ignore[arg-type]
        repo = github_client.get_repo(args.repo)
        print(f"Connected to repository: {repo.full_name}")

    # Process each diagnosis
    results = []
    for i, diagnosis in enumerate(diagnoses, 1):
        print(f"\n[{i}/{len(diagnoses)}] {diagnosis.artist} - {diagnosis.album}")

        if args.dry_run or repo is None:
            result = _process_diagnosis_dry_run(diagnosis, args.repo)
        else:
            result = _process_diagnosis_real(diagnosis, repo, labels)

        results.append(result)

    _print_summary(results, args.input.with_name("issue_results.json"), args)
    return 0


if __name__ == "__main__":
    sys.exit(main())
